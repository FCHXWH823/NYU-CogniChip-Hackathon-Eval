# ========================================================================
# Tiny Tapeout Project Configuration
# ========================================================================
# Project: Moving Average Filter - Smart Low-Power Proximity Sensor SoC
# Authors: Jonathan Farah, Jason Qin
# Repository: git@github.com:jonathan-farah/Sensors_and_Security.git
# ========================================================================

# Tiny Tapeout YAML version (REQUIRED)
yaml_version: 6

# Tiny Tapeout project information
project:
  title: "Moving Average Filter - Configurable Digital Signal Processor"
  author: "Jonathan Farah, Jason Qin"
  description: "8-bit hardware-efficient moving average filter with configurable tap count (1-15), circular buffer architecture, and power-optimized sequential accumulation for sensor data processing. Optimized for Tiny Tapeout pin constraints."
  language: "SystemVerilog"
  clock_hz: 50000000  # 50 MHz target clock frequency (conservative for Tiny Tapeout)
  
  # Tiles configuration (REQUIRED for Tiny Tapeout)
  tiles: "1x1"  # Single tile design
  
  # Top module source file
  source_files:
    - src/tt_um_jonathan_farah_moving_average_filter.sv
  
  top_module: "tt_um_jonathan_farah_moving_average_filter"

# Documentation
documentation:
  author: "Jonathan Farah, Jason Qin"
  title: "Moving Average Filter - Smart Low-Power Proximity Sensor SoC"
  description: "A configurable moving average filter designed for real-time sensor data processing. Features include: runtime-adjustable filter length (1-15 taps), circular buffer eliminating data shifting overhead, sequential accumulation for low power consumption, power-of-2 division optimization using shifts, and standard ready-valid handshake protocol for easy integration."
  how_it_works: |
    The Moving Average Filter implements a sliding window average over the most recent N samples (where N is configurable from 1 to 15).
    
    **Architecture:**
    - **Circular Buffer**: 15-element delay line stores recent samples without shifting data
    - **State Machine**: 4-state FSM (IDLE → ACCUMULATE → DIVIDE → OUTPUT) pipelines the filtering operation
    - **Sequential Accumulation**: One adder accumulates samples over multiple cycles for minimal area and power
    - **Optimized Division**: Power-of-2 tap counts (1,2,4,8) use free bit-shifts; others use hardware divider
    - **Initialization Safety**: Valid sample counter prevents invalid outputs during startup
    
    **Operation:**
    1. Input samples are stored in circular buffer via write pointer
    2. When buffer contains num_taps samples, filtering begins
    3. State machine sequences through: sum all samples → divide by num_taps → output result
    4. Handshake protocol (data_valid/data_ready, result_valid) manages data flow
    
    **Key Features:**
    - Configurable smoothing: 1 tap (pass-through) to 15 taps (maximum noise reduction)
    - Low power: Sequential accumulation vs. parallel tree saves significant power
    - Small area: Circular buffer eliminates shift registers
    - Deterministic timing: num_taps + 2 cycles per result
  
  how_to_test: |
    **Basic Test Procedure:**
    
    1. **Reset**: Assert reset (active-high) for at least 5 clock cycles
    
    2. **Configure**: Set num_taps[3:0] to desired filter length (1-15)
       - Recommended: Start with num_taps = 4 for easy verification
    
    3. **Enable**: Set enable = 1 to activate filter
    
    4. **Send Data**: 
       - Wait for data_ready = 1 (filter ready to accept)
       - Assert data_valid = 1 and present sample on data_in[7:0]
       - Hold for one clock cycle
       - De-assert data_valid = 0
       - Repeat for each sample
    
    5. **Receive Results**:
       - After num_taps samples, watch for result_valid = 1 pulse
       - Capture result_out[7:0] when result_valid is high
       - Result is average of last num_taps samples
    
    **Test Cases:**
    
    **Test 1 - Single Tap (Pass-Through):**
    - Set num_taps = 1
    - Send samples: 50, 100, 150 (8-bit values: 0-255)
    - Expected results: 50, 100, 150 (immediate pass-through)
    
    **Test 2 - Four Tap Average:**
    - Set num_taps = 4
    - Send samples: 16, 32, 48, 64, 80 (8-bit values)
    - First result after 5th sample: (16+32+48+64)/4 = 40
    - Second result after 6th sample: (32+48+64+80)/4 = 56
    
    **Test 3 - Power-of-2 Optimization:**
    - Set num_taps = 8
    - Send samples: 8, 16, 24, 32, 40, 48, 56, 64 (8-bit values)
    - Result: (8+16+24+32+40+48+56+64)/8 = 36 (uses bit-shift, not divider)
    
    **Monitoring:**
    - busy signal indicates filter is computing (cannot accept new data)
    - data_ready indicates filter is idle and can accept data
    
    **Expected Timing (num_taps = 4):**
    - Cycles 1-4: Buffer fill (IDLE state)
    - Cycle 5: Trigger (IDLE → ACCUMULATE)
    - Cycles 6-9: Accumulation (ACCUMULATE state, 4 cycles)
    - Cycle 10: Division (DIVIDE state, 1 cycle)
    - Cycle 11: Output (OUTPUT state, result_valid = 1)
    - Cycle 12+: Ready for next sample (IDLE state)
  
  external_hw: "None required. Design is self-contained. Optional: Connect data_in to ADC or sensor interface. Connect result_out to threshold comparator or display."
  
  discord: ""  # Optional: Your Discord username
  maturity: "Functional"  # Options: Idea, Functional, Tested, Production
  
  # Git information
  repo: "https://github.com/jonathan-farah/Sensors_and_Security"
  commit: ""  # Will be filled automatically
  
  # Licensing
  license: "Apache-2.0"

# Pin configuration for Tiny Tapeout
# Standard TT interface: 8 inputs, 8 outputs, 8 bidirectional
pinout:
  # Dedicated inputs
  inputs:
    - "enable"
    - "num_taps[0]"
    - "num_taps[1]"
    - "num_taps[2]"
    - "num_taps[3]"
    - "data_valid"
    - "data_in[0]"
    - "data_in[1]"
  
  # Dedicated outputs
  outputs:
    - "data_ready"
    - "result_valid"
    - "busy"
    - "result_out[0]"
    - "result_out[1]"
    - "result_out[2]"
    - "result_out[3]"
    - "result_out[4]"
  
  # Bidirectional pins
  bidirectional:
    - "data_in[2]"
    - "data_in[3]"
    - "data_in[4]"
    - "data_in[5]"
    - "data_in[6]"
    - "data_in[7]"
    - "result_out[5]"
    - "result_out[6]"

# Notes for Tiny Tapeout submission
notes: |
  **8-Bit Tiny Tapeout Version**
  
  This design has been optimized for Tiny Tapeout's pin constraints:
  - Reduced from 32-bit to 8-bit data width
  - Fits within standard TT interface: 8 inputs + 8 outputs + 8 bidirectional pins
  - Maintains all functionality of the original 32-bit design
  - Thoroughly tested with comprehensive testbench (6 test scenarios)
  - Waveform verification confirms correct operation
  
  **Design Optimizations:**
  - Low power: Sequential accumulation vs. parallel tree
  - Small area: Circular buffer eliminates shift registers
  - Flexibility: Runtime configurable tap count (1-15)
  - Pin efficiency: 8-bit data path uses all available pins
  
  **Pin Allocation:**
  - Dedicated inputs (8): enable, num_taps[3:0], data_valid, data_in[1:0]
  - Dedicated outputs (8): data_ready, result_valid, busy, result_out[4:0]
  - Bidirectional (8): data_in[7:2] as inputs, result_out[6:5] as outputs
  
  **Recommended First Test:**
  - num_taps = 4 (power-of-2 for easy verification)
  - Input samples: 16, 32, 48, 64
  - Expected result: (16+32+48+64)/4 = 40
  
  Ready for Tiny Tapeout submission!
